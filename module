local L = {}
do
    local P = game:GetService("Players")
    local RS = game:GetService("RunService")
    local UIS = game:GetService("UserInputService")
    local WS = game:GetService("Workspace")
    local C = WS.CurrentCamera
    local LP = P.LocalPlayer
    local V = game:GetService("VirtualInputManager")
    local HC = game:GetService("HttpService")
    
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    
    local function v3(x,y,z) return Vector3.new(x or 0,y or 0,z or 0) end
    local function v2(x,y) return Vector2.new(x or 0,y or 0) end
    
    local function a(p)
        return p and p.Parent and P:FindFirstChild(p.Parent.Name) and 
               p.Parent:FindFirstChild("Humanoid") and 
               p.Parent.Humanoid.Health > 0 and
               p.Parent:FindFirstChild("HumanoidRootPart")
    end
    
    local function ghr(p)
        return p.Character and p.Character:FindFirstChild("HumanoidRootPart")
    end
    
    local function gp(c,n)
        return c and (c:FindFirstChild(n) or c:FindFirstChild("HumanoidRootPart"))
    end
    
    local function w2s(p)
        local v, vis = C:WorldToViewportPoint(p)
        return v2(v.X, v.Y), v.Z, vis
    end
    
    local aim = {
        on = false,
        f = 200,
        b = "Head",
        s = 0.18,
        p = 0.22,
        v = true,
        d = 0.25,
        ac = true,
        aa = 0.35,
        ab = 0.15,
        am = 0.2,
        ah = 0.28,
        al = 0.32,
        az = 0.12,
        ao = 0.18
    }
    
    function aim:gv(t)
        local hrp = t.Parent and t.Parent:FindFirstChild("HumanoidRootPart")
        return hrp and hrp.AssemblyLinearVelocity or v3()
    end
    
    function aim:gt()
        local center = v2(C.ViewportSize.X/2, C.ViewportSize.Y/2)
        local close, dist = nil, self.f
        for _,pl in pairs(P:GetPlayers()) do
            if pl ~= LP and a(pl) then
                local r = ghr(pl)
                if r then
                    local pos, _, vis = w2s(r.Position)
                    if vis then
                        local mag = (pos - center).Magnitude
                        if mag < dist then
                            close, dist = pl, mag
                        end
                    end
                end
            end
        end
        return close
    end
    
    function aim:gp(t)
        local base = t.Position
        local vel = self:gv(t)
        local dist = (C.CFrame.Position - base).Magnitude
        local mul = self.p
        
        if dist > 180 then mul = self.aa
        elseif dist > 140 then mul = self.ab
        elseif dist > 100 then mul = self.am
        elseif dist > 70 then mul = self.ah
        elseif dist > 40 then mul = self.al
        elseif dist < 20 then mul = self.az
        else mul = self.ao end
        
        return base + vel * mul
    end
    
    function aim:up()
        if not self.on then return end
        
        if not UIS.TouchEnabled then return end
        local touches = UIS:GetTouchInputs()
        if #touches == 0 then return end
        
        local t = self:gt()
        if not t then return end
        
        local part = gp(t.Character, self.b)
        if not part then return end
        
        if self.v then
            local p = RaycastParams.new()
            p.FilterDescendantsInstances = {t.Character, LP.Character}
            p.FilterType = Enum.RaycastFilterType.Blacklist
            local ray = WS:Raycast(C.CFrame.Position, (part.Position - C.CFrame.Position).Unit * 500, p)
            if ray then return end
        end
        
        local pos = self:gp(part)
        local vec, vis = w2s(pos)
        
        if vis then
            local center = v2(C.ViewportSize.X/2, C.ViewportSize.Y/2)
            local delta = v2(vec.X, vec.Y) - center
            local move = delta * self.s * 0.018
            
            V:SendMouseMoveEvent(move.X, move.Y)
            
            if self.ac then
                local look = CFrame.lookAt(C.CFrame.Position, pos)
                C.CFrame = C.CFrame:Lerp(look, self.s * 0.5)
            end
        end
    end
    
    local trig = {
        on = false,
        f = 65,
        d = 0.025,
        b = 3,
        bd = 0.012,
        v = true,
        p = 0.18,
        h = 92,
        c = false,
        cd = 0.4
    }
    
    function trig:up()
        if not self.on then return end
        if not UIS.TouchEnabled then return end
        
        local touches = UIS:GetTouchInputs()
        if #touches == 0 then return end
        
        if math.random(1,100) > self.h then return end
        
        local t = aim:gt()
        if not t then return end
        
        local part = gp(t.Character, "Head")
        if not part then return end
        
        if self.v then
            local p = RaycastParams.new()
            p.FilterDescendantsInstances = {t.Character, LP.Character}
            p.FilterType = Enum.RaycastFilterType.Blacklist
            local ray = WS:Raycast(C.CFrame.Position, (part.Position - C.CFrame.Position).Unit * 500, p)
            if ray then return end
        end
        
        task.wait(self.d)
        
        for i = 1, self.b do
            V:SendMouseButtonEvent(0, 0, 0, true, game, 1)
            task.wait(self.bd)
            V:SendMouseButtonEvent(0, 0, 0, false, game, 1)
            if i < self.b then
                task.wait(self.bd)
            end
        end
        
        if self.c then
            task.wait(self.cd)
        end
    end
    
    local silent = {
        on = false,
        hc = 88,
        b = "Head",
        f = 210,
        v = true,
        p = 0.22,
        d = 0.1,
        g = workspace.Gravity,
        w = false
    }
    
    function silent:gt()
        if not self.on then return nil end
        local center = v2(C.ViewportSize.X/2, C.ViewportSize.Y/2)
        local close, dist = nil, self.f
        for _,pl in pairs(P:GetPlayers()) do
            if pl ~= LP and a(pl) then
                local r = ghr(pl)
                if r then
                    local pos, _, vis = w2s(r.Position)
                    if vis then
                        local mag = (pos - center).Magnitude
                        if mag < dist then
                            close, dist = pl, mag
                        end
                    end
                end
            end
        end
        if close then
            local part = gp(close.Character, self.b)
            if part then
                local vis = true
                if self.v then
                    local p = RaycastParams.new()
                    p.FilterDescendantsInstances = {close.Character, LP.Character}
                    p.FilterType = Enum.RaycastFilterType.Blacklist
                    local ray = WS:Raycast(C.CFrame.Position, (part.Position - C.CFrame.Position).Unit * 500, p)
                    vis = ray == nil
                end
                if vis then
                    if self.w then
                        local p = RaycastParams.new()
                        p.FilterDescendantsInstances = {LP.Character, close.Character}
                        p.FilterType = Enum.RaycastFilterType.Blacklist
                        local ray = WS:Raycast(C.CFrame.Position, (part.Position - C.CFrame.Position).Unit * 500, p)
                        if ray then return nil end
                    end
                    local vel = part.AssemblyLinearVelocity
                    local pos = part.Position + vel * self.p
                    local dist = (C.CFrame.Position - part.Position).Magnitude
                    local grav = v3(0, -self.g * self.d * dist * 0.0005, 0)
                    return pos + grav
                end
            end
        end
        return nil
    end
    
    local hb = {
        on = false,
        s = 1.45,
        h = 1.4,
        t = 1.5,
        a = 1.35,
        l = 1.25,
        r = 1.3,
        ls = 1.2,
        rs = 1.2,
        ll = 1.15,
        rl = 1.15,
        enabled = false
    }
    
    function hb:apply()
        if not self.on then return end
        for _,pl in pairs(P:GetPlayers()) do
            if pl ~= LP and pl.Character then
                local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    if not hrp:FindFirstChild("HitboxExpander") then
                        local s = Instance.new("SelectionBox")
                        s.Name = "HitboxExpander"
                        s.Adornee = hrp
                        s.LineThickness = 0
                        s.Transparency = 1
                        s.Color3 = Color3.new(1,1,1)
                        s.SurfaceColor3 = Color3.new(1,1,1)
                        s.SurfaceTransparency = 1
                        s.Parent = hrp
                    end
                    
                    local head = pl.Character:FindFirstChild("Head")
                    local torso = pl.Character:FindFirstChild("Torso") or pl.Character:FindFirstChild("UpperTorso")
                    local leftarm = pl.Character:FindFirstChild("Left Arm") or pl.Character:FindFirstChild("LeftUpperArm")
                    local rightarm = pl.Character:FindFirstChild("Right Arm") or pl.Character:FindFirstChild("RightUpperArm")
                    local leftleg = pl.Character:FindFirstChild("Left Leg") or pl.Character:FindFirstChild("LeftUpperLeg")
                    local rightleg = pl.Character:FindFirstChild("Right Leg") or pl.Character:FindFirstChild("RightUpperLeg")
                    
                    if head then
                        head.Size = v3(2,1,1) * self.h
                        head.Transparency = 0.8
                        head.CanCollide = false
                        head.Material = Enum.Material.Neon
                    end
                    if torso then
                        torso.Size = v3(2,2,1) * self.t
                        torso.Transparency = 0.8
                        torso.CanCollide = false
                        torso.Material = Enum.Material.Neon
                    end
                    if leftarm then
                        leftarm.Size = v3(1,2,1) * self.ls
                        leftarm.Transparency = 0.8
                        leftarm.CanCollide = false
                        leftarm.Material = Enum.Material.Neon
                    end
                    if rightarm then
                        rightarm.Size = v3(1,2,1) * self.rs
                        rightarm.Transparency = 0.8
                        rightarm.CanCollide = false
                        rightarm.Material = Enum.Material.Neon
                    end
                    if leftleg then
                        leftleg.Size = v3(1,2,1) * self.ll
                        leftleg.Transparency = 0.8
                        leftleg.CanCollide = false
                        leftleg.Material = Enum.Material.Neon
                    end
                    if rightleg then
                        rightleg.Size = v3(1,2,1) * self.rl
                        rightleg.Transparency = 0.8
                        rightleg.CanCollide = false
                        rightleg.Material = Enum.Material.Neon
                    end
                end
            end
        end
    end
    
    function hb:reset()
        for _,pl in pairs(P:GetPlayers()) do
            if pl ~= LP and pl.Character then
                local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
                if hrp and hrp:FindFirstChild("HitboxExpander") then
                    hrp.HitboxExpander:Destroy()
                end
                
                local head = pl.Character:FindFirstChild("Head")
                local torso = pl.Character:FindFirstChild("Torso") or pl.Character:FindFirstChild("UpperTorso")
                local leftarm = pl.Character:FindFirstChild("Left Arm") or pl.Character:FindFirstChild("LeftUpperArm")
                local rightarm = pl.Character:FindFirstChild("Right Arm") or pl.Character:FindFirstChild("RightUpperArm")
                local leftleg = pl.Character:FindFirstChild("Left Leg") or pl.Character:FindFirstChild("LeftUpperLeg")
                local rightleg = pl.Character:FindFirstChild("Right Leg") or pl.Character:FindFirstChild("RightUpperLeg")
                
                if head then
                    head.Size = v3(2,1,1)
                    head.Transparency = 0
                    head.CanCollide = true
                    head.Material = Enum.Material.Plastic
                end
                if torso then
                    torso.Size = v3(2,2,1)
                    torso.Transparency = 0
                    torso.CanCollide = true
                    torso.Material = Enum.Material.Plastic
                end
                if leftarm then
                    leftarm.Size = v3(1,2,1)
                    leftarm.Transparency = 0
                    leftarm.CanCollide = true
                    leftarm.Material = Enum.Material.Plastic
                end
                if rightarm then
                    rightarm.Size = v3(1,2,1)
                    rightarm.Transparency = 0
                    rightarm.CanCollide = true
                    rightarm.Material = Enum.Material.Plastic
                end
                if leftleg then
                    leftleg.Size = v3(1,2,1)
                    leftleg.Transparency = 0
                    leftleg.CanCollide = true
                    leftleg.Material = Enum.Material.Plastic
                end
                if rightleg then
                    rightleg.Size = v3(1,2,1)
                    rightleg.Transparency = 0
                    rightleg.CanCollide = true
                    rightleg.Material = Enum.Material.Plastic
                end
            end
        end
    end
    
    local ws = {
        on = false,
        f = 8,
        d = 0.3
    }
    
    function ws:up()
        if not self.on then return end
        if not UIS.TouchEnabled then return end
        
        local touches = UIS:GetTouchInputs()
        if #touches == 0 then return end
        
        for _,pl in pairs(P:GetPlayers()) do
            if pl ~= LP and a(pl) then
                local root = ghr(pl)
                if root then
                    local dist = (LP.Character.HumanoidRootPart.Position - root.Position).Magnitude
                    if dist < self.f then
                        local vel = (LP.Character.HumanoidRootPart.Position - root.Position).Unit * -50
                        root.AssemblyLinearVelocity = vel
                    end
                end
            end
        end
    end
    
    local bt = {
        on = false,
        e = false,
        a = false,
        w = false
    }
    
    mt.__namecall = newcclosure(function(s, ...)
        local a, m = {...}, getnamecallmethod()
        
        if silent.on and (m == "FindPartOnRay" or m == "Raycast") then
            local tp = silent:gt()
            if tp and math.random(1,100) <= silent.hc then
                local dir = (tp - C.CFrame.Position).Unit * 1000
                if type(a[1]) == "userdata" and typeof(a[1]) == "Ray" then
                    local ray = Ray.new(C.CFrame.Position, dir)
                    return old(s, unpack({ray, table.unpack(a, 2)}))
                elseif type(a[1]) == "userdata" and typeof(a[1]) == "Vector3" then
                    return old(s, unpack({C.CFrame.Position, dir, table.unpack(a, 3)}))
                end
            end
        end
        
        return old(s, ...)
    end)
    
    setreadonly(mt, true)
    
    RS.RenderStepped:Connect(function()
        pcall(function()
            aim:up()
            trig:up()
            hb:apply()
            ws:up()
        end)
    end)
    
    P.PlayerAdded:Connect(function(pl)
        pl.CharacterAdded:Connect(function()
            if hb.on then
                task.wait(0.5)
                hb:apply()
            end
        end)
    end)
    
    function L.Aimbot(c)
        if c then for k,v in pairs(c) do aim[k] = v end end
        aim.on = true
        return aim
    end
    
    function L.Trigger(c)
        if c then for k,v in pairs(c) do trig[k] = v end end
        trig.on = true
        return trig
    end
    
    function L.Silent(c)
        if c then for k,v in pairs(c) do silent[k] = v end end
        silent.on = true
        return silent
    end
    
    function L.Hitbox(c)
        if c then for k,v in pairs(c) do hb[k] = v end end
        hb.on = true
        return hb
    end
    
    function L.Whitelist(c)
        return {}
    end
    
    function L.ResetHitbox()
        hb:reset()
    end
    
    function L.Wallbang(c)
        return {}
    end
    
    function L.DisableAll()
        aim.on = false
        trig.on = false
        silent.on = false
        hb.on = false
        ws.on = false
        hb:reset()
    end
    
    function L.IsMobile()
        return UIS.TouchEnabled and not UIS.MouseEnabled
    end
    
    function L.Arsenal()
        return {
            Aimbot = aim,
            Trigger = trig,
            Silent = silent,
            Hitbox = hb
        }
    end
    
    wait(0.1)
    if UIS.TouchEnabled then
        aim.s = 0.22
        aim.p = 0.28
        trig.d = 0.018
        trig.b = 4
        hb.s = 1.5
    end
end

return L
