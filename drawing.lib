local D = (function()
    local S = {
        P = game:GetService("Players"),
        RS = game:GetService("RunService"),
        UIS = game:GetService("UserInputService"),
        WS = game:GetService("Workspace"),
        T = game:GetService("TweenService")
    }
    S.C = S.WS.CurrentCamera
    S.LP = S.P.LocalPlayer

    local C = {
        D = {},
        E = {},
        F = nil,
        S = {},
        V = {}
    }

    local U = {
        V2 = function(x,y) return Vector2.new(x or 0, y or 0) end,
        V3 = function(x,y,z) return Vector3.new(x or 0, y or 0, z or 0) end,
        C3 = function(r,g,b) return Color3.fromRGB(r or 255, g or 255, b or 255) end,
        CL = function(n,l,h) return math.clamp(n, l or 0, h or 1) end,
        F = math.floor,
        M = math.min,
        X = math.max,
        A = math.abs,
        R = math.rad,
        T = tick
    }

    local P = {
        Enemy = U.C3(255, 80, 80),
        Friend = U.C3(80, 255, 120),
        Outline = U.C3(0, 0, 0),
        Text = U.C3(255, 255, 255),
        HealthG = U.C3(80, 255, 80),
        HealthY = U.C3(255, 220, 80),
        HealthR = U.C3(255, 80, 80),
        FOV = U.C3(255, 120, 120),
        Tracer = U.C3(255, 80, 80),
        Skeleton = U.C3(255, 255, 255),
        Head = U.C3(255, 220, 40)
    }

    local G = {
        E = false,
        R = 120,
        B = {
            W = 55,
            H = 110,
            T = 1,
            OT = 2,
            S = 750,
            SM = 0.6,
            SX = 2.5,
            HB = true,
            NT = true,
            D = true,
            TC = true
        },
        C = {
            E = false,
            L = 8,
            T = 2
        },
        TR = {
            E = false,
            T = 1
        },
        H = {
            E = false,
            R = 4
        },
        SK = {
            E = false,
            T = 2,
            TR = 0.2
        }
    }

    local function DR(t, p)
        local s, d = pcall(function() return Drawing.new(t) end)
        if s and d then
            for k, v in pairs(p or {}) do
                pcall(function() d[k] = v end)
            end
            table.insert(C.D, d)
            return d
        end
    end

    local function W2S(w)
        if not S.C then return U.V2(), 0, false end
        local v, vf = S.C:WorldToViewportPoint(w)
        return U.V2(v.X, v.Y), v.Z, vf
    end

    local function VC()
        return U.V2(S.C.ViewportSize.X/2, S.C.ViewportSize.Y/2)
    end

    local function VV(p)
        if not p or not p.Character then return false end
        local c = p.Character
        local h = c:FindFirstChild("Humanoid")
        local r = c:FindFirstChild("HumanoidRootPart")
        return h and r and h.Health > 0
    end

    local function CE(p)
        if C.E[p] then return C.E[p] end
        local e = {}
        
        e.BO = DR("Square", {T = G.B.OT, C = P.Outline, F = false, V = false})
        e.B = DR("Square", {T = G.B.T, C = P.Enemy, F = false, V = false})
        
        if G.C.E then
            for i = 1, 8 do
                e["C"..i] = DR("Line", {T = G.C.T, C = P.Outline, V = false})
            end
        end
        
        if G.B.NT then
            e.N = DR("Text", {T = p.Name, C = P.Text, S = 16, Cen = true, O = true, OC = P.Outline, V = false})
        end
        
        if G.B.HB then
            e.HB = DR("Square", {C = P.Outline, F = true, TR = 0.5, V = false})
            e.HF = DR("Square", {C = P.HealthG, F = true, TR = 0.2, V = false})
        end
        
        if G.B.D then
            e.D = DR("Text", {T = "0M", C = P.Text, S = 13, Cen = true, O = true, OC = P.Outline, V = false})
        end
        
        if G.H.E then
            e.H = DR("Circle", {R = G.H.R, F = true, C = P.Head, TR = 0.3, V = false, NS = 16})
        end
        
        if G.TR.E then
            e.T = DR("Line", {T = G.TR.T, C = P.Tracer, V = false})
        end
        
        if G.SK.E then
            e.SK = {}
            local b = {"Hd", "To", "LA", "RA", "LL", "RL"}
            for _, v in ipairs(b) do
                if v == "Hd" then
                    e.SK[v] = DR("Circle", {R = 3, F = true, C = P.Head, V = false})
                elseif v == "To" then
                    e.SK[v] = DR("Square", {F = true, C = G.SK.C or P.Skeleton, TR = G.SK.TR, V = false})
                else
                    e.SK[v] = DR("Line", {T = G.SK.T, C = G.SK.C or P.Skeleton, TR = G.SK.TR, V = false})
                end
            end
        end
        
        C.E[p] = e
        return e
    end

    local function UC(e, x, y, w, h)
        if not e or not G.C.E then return end
        local l = G.C.L
        local ps = {
            {U.V2(x - w/2, y - h/2), U.V2(x - w/2 + l, y - h/2)},
            {U.V2(x - w/2, y - h/2), U.V2(x - w/2, y - h/2 + l)},
            {U.V2(x + w/2, y - h/2), U.V2(x + w/2 - l, y - h/2)},
            {U.V2(x + w/2, y - h/2), U.V2(x + w/2, y - h/2 + l)},
            {U.V2(x - w/2, y + h/2), U.V2(x - w/2 + l, y + h/2)},
            {U.V2(x - w/2, y + h/2), U.V2(x - w/2, y + h/2 - l)},
            {U.V2(x + w/2, y + h/2), U.V2(x + w/2 - l, y + h/2)},
            {U.V2(x + w/2, y + h/2), U.V2(x + w/2, y + h/2 - l)}
        }
        for i = 1, 8 do
            if e["C"..i] then
                e["C"..i].From = ps[i][1]
                e["C"..i].To = ps[i][2]
                e["C"..i].Visible = G.E
            end
        end
    end

    local function US(e, c)
        if not c or not e.SK or not G.SK.E then return end
        local hd = c:FindFirstChild("Head")
        local to = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
        local la = c:FindFirstChild("Left Arm") or c:FindFirstChild("LeftHand") or c:FindFirstChild("LeftUpperArm")
        local ra = c:FindFirstChild("Right Arm") or c:FindFirstChild("RightHand") or c:FindFirstChild("RightUpperArm")
        local ll = c:FindFirstChild("Left Leg") or c:FindFirstChild("LeftLowerLeg") or c:FindFirstChild("LeftFoot")
        local rl = c:FindFirstChild("Right Leg") or c:FindFirstChild("RightLowerLeg") or c:FindFirstChild("RightFoot")
        
        if hd and e.SK.Hd then
            local p, _, v = W2S(hd.Position)
            if v then e.SK.Hd.Position = p; e.SK.Hd.Visible = G.E end
        end
        
        if to and e.SK.To then
            local p, _, v = W2S(to.Position)
            if v then
                e.SK.To.Position = U.V2(p.X - 15, p.Y - 20)
                e.SK.To.Size = U.V2(30, 40)
                e.SK.To.Visible = G.E
            end
        end
        
        if la and e.SK.LA and to then
            local lp, lv = W2S(la.Position)
            local tp, tv = W2S(to.Position)
            if lv and tv then
                e.SK.LA.From = tp
                e.SK.LA.To = lp
                e.SK.LA.Visible = G.E
            end
        end
        
        if ra and e.SK.RA and to then
            local rp, rv = W2S(ra.Position)
            local tp, tv = W2S(to.Position)
            if rv and tv then
                e.SK.RA.From = tp
                e.SK.RA.To = rp
                e.SK.RA.Visible = G.E
            end
        end
        
        if ll and e.SK.LL and to then
            local lp, lv = W2S(ll.Position)
            local tp, tv = W2S(to.Position)
            if lv and tv then
                e.SK.LL.From = U.V2(tp.X, tp.Y + 15)
                e.SK.LL.To = lp
                e.SK.LL.Visible = G.E
            end
        end
        
        if rl and e.SK.RL and to then
            local rp, rv = W2S(rl.Position)
            local tp, tv = W2S(to.Position)
            if rv and tv then
                e.SK.RL.From = U.V2(tp.X, tp.Y + 15)
                e.SK.RL.To = rp
                e.SK.RL.Visible = G.E
            end
        end
    end

    local function PX(pl)
        if not G.E or not pl or pl == S.LP then return end
        if not VV(pl) then
            if C.E[pl] then
                for _, d in pairs(C.E[pl]) do
                    if type(d) == "table" then for _, sd in pairs(d) do pcall(function() sd.Visible = false end) end
                    else pcall(function() d.Visible = false end) end
                end
            end
            return
        end
        
        local c = pl.Character
        local r = c and c:FindFirstChild("HumanoidRootPart")
        local h = c and c:FindFirstChild("Humanoid")
        if not r or not h then return end
        
        local v2, d3, vf = W2S(r.Position)
        if not vf then return end
        
        local e = CE(pl)
        local s = U.CL(G.B.S / (d3 + 0.01), G.B.SM, G.B.SX)
        local w = U.F(G.B.W * s)
        local hx = U.F(G.B.H * s)
        local x, y = v2.X, v2.Y
        
        local tc = pl.Team and S.LP.Team and pl.Team == S.LP.Team
        local bc = tc and P.Friend or P.Enemy
        
        if e.B and e.BO then
            e.B.Position = U.V2(x - w/2, y - hx/2)
            e.B.Size = U.V2(w, hx)
            e.B.Color = bc
            e.B.Visible = G.E
            e.BO.Position = U.V2(x - w/2 - 1, y - hx/2 - 1)
            e.BO.Size = U.V2(w + 2, hx + 2)
            e.BO.Visible = G.E
        end
        
        if G.C.E then UC(e, x, y, w, hx) end
        
        if e.HB and e.HF and G.B.HB then
            local hp = h.Health / h.MaxHealth
            local hc = hp > 0.6 and P.HealthG or hp > 0.3 and P.HealthY or P.HealthR
            e.HB.Position = U.V2(x + w/2 + 4, y - hx/2)
            e.HB.Size = U.V2(5, hx)
            e.HB.Visible = G.E
            e.HF.Position = U.V2(x + w/2 + 4, y + hx/2 - (hx * hp))
            e.HF.Size = U.V2(5, hx * hp)
            e.HF.Color = hc
            e.HF.Visible = G.E
        end
        
        if e.N and G.B.NT then
            e.N.Position = U.V2(x, y - hx/2 - 22)
            e.N.Text = string.upper(pl.Name)
            e.N.Visible = G.E
        end
        
        if e.D and G.B.D and S.LP.Character and S.LP.Character:FindFirstChild("HumanoidRootPart") then
            local lr = S.LP.Character.HumanoidRootPart
            local d = U.F((lr.Position - r.Position).Magnitude)
            e.D.Position = U.V2(x, y + hx/2 + 20)
            e.D.Text = d .. "M"
            e.D.Visible = G.E
        end
        
        if e.H and G.H.E and c:FindFirstChild("Head") then
            local hp, hv = W2S(c.Head.Position)
            if hv then e.H.Position = hp; e.H.Visible = G.E end
        end
        
        if e.T and G.TR.E and S.C then
            e.T.From = U.V2(S.C.ViewportSize.X/2, S.C.ViewportSize.Y)
            e.T.To = U.V2(x, y - hx/3)
            e.T.Color = bc
            e.T.Visible = G.E
        end
        
        if G.SK.E then US(e, c) end
    end

    local function CL()
        for p, _ in pairs(C.E) do
            if not p or not p.Parent or not VV(p) then
                if C.E[p] then
                    for _, d in pairs(C.E[p]) do
                        if type(d) == "table" then for _, sd in pairs(d) do pcall(function() sd:Remove() end) end
                        else pcall(function() d:Remove() end) end
                    end
                    C.E[p] = nil
                end
            end
        end
    end

    local M = {}

    function M.Enable()
        G.E = true
        if not C.F then
            C.F = DR("Circle", {
                R = G.R,
                C = P.FOV,
                T = 1.25,
                NS = 72,
                F = false,
                TR = 0.85,
                V = true,
                P = VC()
            })
        end
    end

    function M.Disable()
        G.E = false
        if C.F then pcall(function() C.F.Visible = false end) end
        for p, _ in pairs(C.E) do
            if C.E[p] then
                for _, d in pairs(C.E[p]) do
                    if type(d) == "table" then for _, sd in pairs(d) do pcall(function() sd.Visible = false end) end
                    else pcall(function() d.Visible = false end) end
                end
            end
        end
    end

    function M.Toggle()
        if G.E then M.Disable() else M.Enable() end
    end

    function M.SetFOV(r)
        G.R = r or 120
        if C.F then pcall(function() C.F.Radius = G.R end) end
    end

    function M.SetFOVColor(r,g,b)
        P.FOV = U.C3(r,g,b)
        if C.F then pcall(function() C.F.Color = P.FOV end) end
    end

    function M.ToggleCorner(e)
        G.C.E = e ~= nil and e or not G.C.E
    end

    function M.ToggleTracer(e)
        G.TR.E = e ~= nil and e or not G.TR.E
    end

    function M.ToggleHead(e)
        G.H.E = e ~= nil and e or not G.H.E
    end

    function M.ToggleSkeleton(e)
        G.SK.E = e ~= nil and e or not G.SK.E
    end

    function M.ToggleHealthBar(e)
        G.B.HB = e ~= nil and e or not G.B.HB
    end

    function M.ToggleName(e)
        G.B.NT = e ~= nil and e or not G.B.NT
    end

    function M.ToggleDistance(e)
        G.B.D = e ~= nil and e or not G.B.D
    end

    function M.ToggleTeamColor(e)
        G.B.TC = e ~= nil and e or not G.B.TC
    end

    function M.Reset()
        for _, d in pairs(C.D) do pcall(function() d:Remove() end) end
        C.D = {}; C.E = {}; C.F = nil
    end

    function M.IsEnabled()
        return G.E
    end

    S.RS.RenderStepped:Connect(function()
        if not S.C then S.C = S.WS.CurrentCamera end
        if not S.C then return end
        
        if C.F and G.E then
            pcall(function() C.F.Position = VC(); C.F.Visible = true end)
        elseif C.F then
            pcall(function() C.F.Visible = false end)
        end
        
        if G.E then
            for _, p in ipairs(S.P:GetPlayers()) do
                if p ~= S.LP then PX(p) end
            end
            CL()
        end
    end)

    return M
end)()

_G.ARC = _G.ARC or {}
_G.ARC.Visual = D
return D
