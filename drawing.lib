local S = setmetatable({}, {__index = function(_, k) return game:GetService(k) end})
S.Players = game:GetService("Players")
S.RunService = game:GetService("RunService")
S.Workspace = workspace
S.Tween = game:GetService("TweenService")
S.UIS = game:GetService("UserInputService")

local L = S.Players.LocalPlayer
local C = S.Workspace.CurrentCamera

local D = {}
local E = {}
local F = nil
local G = false

local function C3(r,g,b) return Color3.fromRGB(r,g,b) end
local function C4(r,g,b,a) return Color3.fromRGB(r,g,b), a end

local P = {
    enemy = C3(255, 70, 70),
    friend = C3(70, 255, 120),
    box = C3(255, 255, 255),
    outline = C3(0, 0, 0),
    head = C3(255, 220, 40),
    text = C3(255, 255, 255),
    distance = C3(200, 200, 200),
    health_green = C3(70, 255, 70),
    health_yellow = C3(255, 220, 70),
    health_red = C3(255, 70, 70),
    fov = C3(255, 110, 110)
}

local function safe_draw(t, p)
    local s, d = pcall(function() return Drawing.new(t) end)
    if s and d then
        for k, v in pairs(p or {}) do
            pcall(function() d[k] = v end)
        end
        table.insert(D, d)
        return d
    end
    return nil
end

local function update_fov()
    if F and G and C then
        pcall(function()
            F.Position = Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y/2)
            F.Visible = true
        end)
    elseif F then
        pcall(function() F.Visible = false end)
    end
end

local function world_to_viewport(w)
    local v, vf = C:WorldToViewportPoint(w)
    return Vector2.new(v.X, v.Y), v.Z, vf
end

local function cleanup_player(p)
    if E[p] then
        for _, d in pairs(E[p]) do
            pcall(function() d:Remove() end)
        end
        E[p] = nil
    end
end

local function construct_player_esp(p)
    if E[p] then return E[p] end
    
    local esp = {}
    
    esp.box_outline = safe_draw("Square", {
        Thickness = 2.5,
        Color = P.outline,
        Filled = false,
        Transparency = 1,
        Visible = false,
        ZIndex = 1
    })
    
    esp.box = safe_draw("Square", {
        Thickness = 1.25,
        Color = P.enemy,
        Filled = false,
        Transparency = 1,
        Visible = false,
        ZIndex = 2
    })
    
    esp.corner_tl = safe_draw("Line", {Thickness = 1.5, Color = P.box, Visible = false})
    esp.corner_tr = safe_draw("Line", {Thickness = 1.5, Color = P.box, Visible = false})
    esp.corner_bl = safe_draw("Line", {Thickness = 1.5, Color = P.box, Visible = false})
    esp.corner_br = safe_draw("Line", {Thickness = 1.5, Color = P.box, Visible = false})
    
    esp.name = safe_draw("Text", {
        Text = string.upper(p.Name),
        Color = P.text,
        Size = 16,
        Center = true,
        Outline = true,
        OutlineColor = P.outline,
        Visible = false,
        ZIndex = 3
    })
    
    esp.health_bg = safe_draw("Square", {
        Color = P.outline,
        Filled = true,
        Transparency = 0.55,
        Visible = false
    })
    
    esp.health_fill = safe_draw("Square", {
        Color = P.health_green,
        Filled = true,
        Transparency = 0.25,
        Visible = false
    })
    
    esp.health_text = safe_draw("Text", {
        Text = "100",
        Color = P.text,
        Size = 12,
        Center = true,
        Outline = true,
        OutlineColor = P.outline,
        Visible = false,
        ZIndex = 3
    })
    
    esp.distance = safe_draw("Text", {
        Text = "0M",
        Color = P.distance,
        Size = 13,
        Center = true,
        Outline = true,
        OutlineColor = P.outline,
        Visible = false,
        ZIndex = 3
    })
    
    esp.head = safe_draw("Circle", {
        Radius = 3,
        Filled = true,
        Color = P.head,
        Transparency = 0.3,
        Visible = false,
        NumSides = 16
    })
    
    esp.tracer = safe_draw("Line", {
        Thickness = 1,
        Color = P.enemy,
        Transparency = 0.5,
        Visible = false
    })
    
    esp.skeleton = {
        head = safe_draw("Circle", {Radius = 2, Filled = true, Color = P.head, Visible = false}),
        torso = safe_draw("Square", {Filled = true, Color = P.enemy, Transparency = 0.5, Visible = false}),
        larm = safe_draw("Line", {Thickness = 2, Color = P.box, Visible = false}),
        rarm = safe_draw("Line", {Thickness = 2, Color = P.box, Visible = false}),
        lleg = safe_draw("Line", {Thickness = 2, Color = P.box, Visible = false}),
        rleg = safe_draw("Line", {Thickness = 2, Color = P.box, Visible = false})
    }
    
    E[p] = esp
    return esp
end

local function update_box_esp(p, esp, pos, size, color, x, y)
    if esp.box and esp.box_outline then
        esp.box.Position = Vector2.new(x - size.X/2, y - size.Y/2)
        esp.box.Size = size
        esp.box.Color = color
        esp.box.Visible = G
        
        esp.box_outline.Position = Vector2.new(x - size.X/2 - 1, y - size.Y/2 - 1)
        esp.box_outline.Size = Vector2.new(size.X + 2, size.Y + 2)
        esp.box_outline.Visible = G
    end
end

local function update_corners(p, esp, size, x, y)
    local cl = 6
    local cw = 4
    
    if esp.corner_tl then
        esp.corner_tl.From = Vector2.new(x - size.X/2, y - size.Y/2)
        esp.corner_tl.To = Vector2.new(x - size.X/2 + cl, y - size.Y/2)
        esp.corner_tl.Visible = G
        
        local _, d = pcall(function()
            local l = safe_draw("Line", {})
            l.From = Vector2.new(x - size.X/2, y - size.Y/2)
            l.To = Vector2.new(x - size.X/2, y - size.Y/2 + cl)
            l.Thickness = cw
            l.Color = P.box
            l.Visible = G
            if esp.corner_tl_vert then pcall(function() esp.corner_tl_vert:Remove() end) end
            esp.corner_tl_vert = l
        end)
    end
    
    if esp.corner_tr then
        esp.corner_tr.From = Vector2.new(x + size.X/2, y - size.Y/2)
        esp.corner_tr.To = Vector2.new(x + size.X/2 - cl, y - size.Y/2)
        esp.corner_tr.Visible = G
        
        local _, d = pcall(function()
            local l = safe_draw("Line", {})
            l.From = Vector2.new(x + size.X/2, y - size.Y/2)
            l.To = Vector2.new(x + size.X/2, y - size.Y/2 + cl)
            l.Thickness = cw
            l.Color = P.box
            l.Visible = G
            if esp.corner_tr_vert then pcall(function() esp.corner_tr_vert:Remove() end) end
            esp.corner_tr_vert = l
        end)
    end
    
    if esp.corner_bl then
        esp.corner_bl.From = Vector2.new(x - size.X/2, y + size.Y/2)
        esp.corner_bl.To = Vector2.new(x - size.X/2 + cl, y + size.Y/2)
        esp.corner_bl.Visible = G
        
        local _, d = pcall(function()
            local l = safe_draw("Line", {})
            l.From = Vector2.new(x - size.X/2, y + size.Y/2)
            l.To = Vector2.new(x - size.X/2, y + size.Y/2 - cl)
            l.Thickness = cw
            l.Color = P.box
            l.Visible = G
            if esp.corner_bl_vert then pcall(function() esp.corner_bl_vert:Remove() end) end
            esp.corner_bl_vert = l
        end)
    end
    
    if esp.corner_br then
        esp.corner_br.From = Vector2.new(x + size.X/2, y + size.Y/2)
        esp.corner_br.To = Vector2.new(x + size.X/2 - cl, y + size.Y/2)
        esp.corner_br.Visible = G
        
        local _, d = pcall(function()
            local l = safe_draw("Line", {})
            l.From = Vector2.new(x + size.X/2, y + size.Y/2)
            l.To = Vector2.new(x + size.X/2, y + size.Y/2 - cl)
            l.Thickness = cw
            l.Color = P.box
            l.Visible = G
            if esp.corner_br_vert then pcall(function() esp.corner_br_vert:Remove() end) end
            esp.corner_br_vert = l
        end)
    end
end

local function update_health(p, esp, humanoid, x, y, size)
    if esp.health_bg and esp.health_fill and humanoid then
        local hp = humanoid.Health
        local max_hp = humanoid.MaxHealth
        local percent = hp / max_hp
        local bar_height = size.Y
        local bar_width = 4.5
        
        local health_color = percent > 0.6 and P.health_green or percent > 0.3 and P.health_yellow or P.health_red
        
        esp.health_bg.Position = Vector2.new(x + size.X/2 + 4, y - size.Y/2)
        esp.health_bg.Size = Vector2.new(bar_width, bar_height)
        esp.health_bg.Visible = G
        
        esp.health_fill.Position = Vector2.new(x + size.X/2 + 4, y + size.Y/2 - (bar_height * percent))
        esp.health_fill.Size = Vector2.new(bar_width, bar_height * percent)
        esp.health_fill.Color = health_color
        esp.health_fill.Visible = G
        
        if esp.health_text then
            esp.health_text.Position = Vector2.new(x + size.X/2 + 12, y)
            esp.health_text.Text = tostring(math.floor(hp)) .. "/" .. tostring(math.floor(max_hp))
            esp.health_text.Visible = G
        end
    end
end

local function update_name(esp, x, y, size, name)
    if esp.name then
        esp.name.Position = Vector2.new(x, y - size.Y/2 - 20)
        esp.name.Text = name
        esp.name.Visible = G
    end
end

local function update_distance(p, esp, root, x, y, size)
    if esp.distance and L.Character and L.Character:FindFirstChild("HumanoidRootPart") then
        local lr = L.Character.HumanoidRootPart
        local dist = math.floor((lr.Position - root.Position).Magnitude)
        esp.distance.Position = Vector2.new(x, y + size.Y/2 + 18)
        esp.distance.Text = tostring(dist) .. "M"
        esp.distance.Visible = G
    end
end

local function update_head(p, esp, character, pos)
    if esp.head and character:FindFirstChild("Head") then
        local head = character.Head
        local hpos, hvis = world_to_viewport(head.Position)
        if hvis then
            esp.head.Position = Vector2.new(hpos.X, hpos.Y)
            esp.head.Visible = G
        end
    end
end

local function update_tracer(esp, x, y, color)
    if esp.tracer and C then
        esp.tracer.From = Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y)
        esp.tracer.To = Vector2.new(x, y)
        esp.tracer.Color = color
        esp.tracer.Visible = G
    end
end

local function update_skeleton(p, esp, character)
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    local la = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftHand")
    local ra = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand")
    local ll = character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftLowerLeg")
    local rl = character:FindFirstChild("Right Leg") or character:FindFirstChild("RightLowerLeg")
    
    if esp.skeleton.head and head then
        local hpos, hvis = world_to_viewport(head.Position)
        if hvis then
            esp.skeleton.head.Position = Vector2.new(hpos.X, hpos.Y)
            esp.skeleton.head.Visible = G
        end
    end
    
    if esp.skeleton.torso and torso then
        local tpos, tvis = world_to_viewport(torso.Position)
        if tvis then
            local size = Vector2.new(20, 30)
            esp.skeleton.torso.Position = Vector2.new(tpos.X - size.X/2, tpos.Y - size.Y/2)
            esp.skeleton.torso.Size = size
            esp.skeleton.torso.Visible = G
        end
    end
    
    if esp.skeleton.larm and la and torso then
        local lpos, lvis = world_to_viewport(la.Position)
        local tpos, tvis = world_to_viewport(torso.Position)
        if lvis and tvis then
            esp.skeleton.larm.From = Vector2.new(tpos.X, tpos.Y)
            esp.skeleton.larm.To = Vector2.new(lpos.X, lpos.Y)
            esp.skeleton.larm.Visible = G
        end
    end
    
    if esp.skeleton.rarm and ra and torso then
        local rpos, rvis = world_to_viewport(ra.Position)
        local tpos, tvis = world_to_viewport(torso.Position)
        if rvis and tvis then
            esp.skeleton.rarm.From = Vector2.new(tpos.X, tpos.Y)
            esp.skeleton.rarm.To = Vector2.new(rpos.X, rpos.Y)
            esp.skeleton.rarm.Visible = G
        end
    end
    
    if esp.skeleton.lleg and ll and torso then
        local llpos, llvis = world_to_viewport(ll.Position)
        local tpos, tvis = world_to_viewport(torso.Position)
        if llvis and tvis then
            esp.skeleton.lleg.From = Vector2.new(tpos.X, tpos.Y + 15)
            esp.skeleton.lleg.To = Vector2.new(llpos.X, llpos.Y)
            esp.skeleton.lleg.Visible = G
        end
    end
    
    if esp.skeleton.rleg and rl and torso then
        local rlpos, rlvis = world_to_viewport(rl.Position)
        local tpos, tvis = world_to_viewport(torso.Position)
        if rlvis and tvis then
            esp.skeleton.rleg.From = Vector2.new(tpos.X, tpos.Y + 15)
            esp.skeleton.rleg.To = Vector2.new(rlpos.X, rlpos.Y)
            esp.skeleton.rleg.Visible = G
        end
    end
end

local function hide_player(p)
    if E[p] then
        for _, d in pairs(E[p]) do
            if type(d) == "table" then
                for _, sd in pairs(d) do
                    pcall(function() sd.Visible = false end)
                end
            else
                pcall(function() d.Visible = false end)
            end
        end
    end
end

local function process_player(p)
    if not G or not p or p == L then return end
    if not E[p] then construct_player_esp(p) end
    
    local c = p.Character
    if not c then 
        hide_player(p)
        return 
    end
    
    local r = c:FindFirstChild("HumanoidRootPart")
    local h = c:FindFirstChild("Humanoid")
    
    if not r or not h or h.Health <= 0 then
        hide_player(p)
        return
    end
    
    local v2, d3, vf = world_to_viewport(r.Position)
    if not vf then
        hide_player(p)
        return
    end
    
    local esp = E[p]
    if not esp then return end
    
    local dist_scale = math.clamp(400 / (d3 + 0.01), 0.45, 2.2)
    local box_size = Vector2.new(math.floor(32 * dist_scale), math.floor(64 * dist_scale))
    local x, y = v2.X, v2.Y
    
    local team_color = p.Team and L.Team and p.Team == L.Team and P.friend or P.enemy
    
    update_box_esp(p, esp, v2, box_size, team_color, x, y)
    update_corners(p, esp, box_size, x, y)
    update_health(p, esp, h, x, y, box_size)
    update_name(esp, x, y, box_size, string.upper(p.Name))
    update_distance(p, esp, r, x, y, box_size)
    update_head(p, esp, c, v2)
    update_tracer(esp, x, y, team_color)
    update_skeleton(p, esp, c)
end

local function cleanup()
    for p, _ in pairs(E) do
        if not p or not p.Parent then
            cleanup_player(p)
        end
    end
end

local function full_reset()
    for _, d in pairs(D) do
        pcall(function() d:Remove() end)
    end
    D = {}
    E = {}
    if F then pcall(function() F:Remove() end) F = nil end
end

local M = {}

function M.Enable()
    G = true
    if not F then
        F = safe_draw("Circle", {
            Radius = 120,
            Color = P.fov,
            Thickness = 1.25,
            NumSides = 72,
            Filled = false,
            Transparency = 0.85,
            Visible = true,
            Position = C and Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y/2) or Vector2.new(960, 540)
        })
    end
end

function M.Disable()
    G = false
    if F then pcall(function() F.Visible = false end) end
    for p, _ in pairs(E) do
        hide_player(p)
    end
end

function M.Toggle()
    if G then M.Disable() else M.Enable() end
end

function M.SetFOVRadius(r)
    if F then
        pcall(function() F.Radius = r end)
    end
end

function M.SetFOVColor(r,g,b)
    if F then
        pcall(function() F.Color = C3(r,g,b) end)
    end
end

function M.SetBoxThickness(t)
    P.box_thickness = t or 1.25
end

function M.SetEnemyColor(r,g,b)
    P.enemy = C3(r,g,b)
end

function M.SetFriendColor(r,g,b)
    P.friend = C3(r,g,b)
end

function M.Reset()
    full_reset()
end

function M.IsEnabled()
    return G
end

S.RunService.RenderStepped:Connect(function()
    if not C then C = S.Workspace.CurrentCamera end
    if not C then return end
    
    update_fov()
    
    if G then
        for _, p in pairs(S.Players:GetPlayers()) do
            if p ~= L then
                process_player(p)
            end
        end
        cleanup()
    end
end)

_G.VISUALS = M

return M
