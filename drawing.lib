local S = setmetatable({}, {__index = function(_, k) return game:GetService(k) end})
S.Players = game:GetService("Players")
S.RunService = game:GetService("RunService")
S.Workspace = workspace
S.Tween = game:GetService("TweenService")
S.UIS = game:GetService("UserInputService")

local L = S.Players.LocalPlayer
local C = S.Workspace.CurrentCamera

local D = {}
local E = {}
local F = nil
local G = false

local function C3(r,g,b) return Color3.fromRGB(r,g,b) end

local P = {
    enemy = C3(255, 70, 70),
    friend = C3(70, 255, 120),
    box = C3(255, 255, 255),
    outline = C3(0, 0, 0),
    head = C3(255, 220, 40),
    text = C3(255, 255, 255),
    distance = C3(200, 200, 200),
    health_green = C3(70, 255, 70),
    health_yellow = C3(255, 220, 70),
    health_red = C3(255, 70, 70),
    fov = C3(255, 110, 110)
}

local function safe_draw(t, p)
    local s, d = pcall(function() return Drawing.new(t) end)
    if s and d then
        for k, v in pairs(p or {}) do
            pcall(function() d[k] = v end)
        end
        table.insert(D, d)
        return d
    end
    return nil
end

local function update_fov()
    if F and G and C then
        pcall(function()
            F.Position = Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y/2)
            F.Visible = true
        end)
    elseif F then
        pcall(function() F.Visible = false end)
    end
end

local function world_to_viewport(w)
    local v, vf = C:WorldToViewportPoint(w)
    return Vector2.new(v.X, v.Y), v.Z, vf
end

local function cleanup_player(p)
    if E[p] then
        for _, d in pairs(E[p]) do
            if type(d) == "table" then
                for _, sd in pairs(d) do
                    pcall(function() sd:Remove() end)
                end
            else
                pcall(function() d:Remove() end)
            end
        end
        E[p] = nil
    end
end

local function construct_player_esp(p)
    if E[p] then return E[p] end
    
    local esp = {}
    
    esp.box_outline = safe_draw("Square", {
        Thickness = 2,
        Color = P.outline,
        Filled = false,
        Visible = false
    })
    
    esp.box = safe_draw("Square", {
        Thickness = 1,
        Color = P.enemy,
        Filled = false,
        Visible = false
    })
    
    for i = 1, 8 do
        esp["corner_"..i] = safe_draw("Line", {
            Thickness = 2,
            Color = P.box,
            Visible = false
        })
    end
    
    esp.name = safe_draw("Text", {
        Text = p.Name,
        Color = P.text,
        Size = 16,
        Center = true,
        Outline = true,
        OutlineColor = P.outline,
        Visible = false
    })
    
    esp.health_bg = safe_draw("Square", {
        Color = P.outline,
        Filled = true,
        Transparency = 0.5,
        Visible = false
    })
    
    esp.health_fill = safe_draw("Square", {
        Color = P.health_green,
        Filled = true,
        Transparency = 0.2,
        Visible = false
    })
    
    esp.distance = safe_draw("Text", {
        Text = "0M",
        Color = P.distance,
        Size = 13,
        Center = true,
        Outline = true,
        OutlineColor = P.outline,
        Visible = false
    })
    
    esp.head = safe_draw("Circle", {
        Radius = 4,
        Filled = true,
        Color = P.head,
        Transparency = 0.3,
        Visible = false,
        NumSides = 16
    })
    
    esp.tracer = safe_draw("Line", {
        Thickness = 1,
        Color = P.enemy,
        Transparency = 0.5,
        Visible = false
    })
    
    esp.skeleton = {}
    local bones = {"head", "torso", "leftarm", "rightarm", "leftleg", "rightleg"}
    for _, bone in ipairs(bones) do
        if bone == "head" then
            esp.skeleton[bone] = safe_draw("Circle", {
                Radius = 3,
                Filled = true,
                Color = P.head,
                Visible = false
            })
        elseif bone == "torso" then
            esp.skeleton[bone] = safe_draw("Square", {
                Filled = true,
                Color = P.enemy,
                Transparency = 0.4,
                Visible = false
            })
        else
            esp.skeleton[bone] = safe_draw("Line", {
                Thickness = 2,
                Color = P.box,
                Visible = false
            })
        end
    end
    
    E[p] = esp
    return esp
end

local function update_corners(esp, x, y, w, h)
    if not esp then return end
    local corner_len = 8
    local corners = {
        esp.corner_1, esp.corner_2, esp.corner_3, esp.corner_4,
        esp.corner_5, esp.corner_6, esp.corner_7, esp.corner_8
    }
    
    local positions = {
        {Vector2.new(x - w/2, y - h/2), Vector2.new(x - w/2 + corner_len, y - h/2)},
        {Vector2.new(x - w/2, y - h/2), Vector2.new(x - w/2, y - h/2 + corner_len)},
        {Vector2.new(x + w/2, y - h/2), Vector2.new(x + w/2 - corner_len, y - h/2)},
        {Vector2.new(x + w/2, y - h/2), Vector2.new(x + w/2, y - h/2 + corner_len)},
        {Vector2.new(x - w/2, y + h/2), Vector2.new(x - w/2 + corner_len, y + h/2)},
        {Vector2.new(x - w/2, y + h/2), Vector2.new(x - w/2, y + h/2 - corner_len)},
        {Vector2.new(x + w/2, y + h/2), Vector2.new(x + w/2 - corner_len, y + h/2)},
        {Vector2.new(x + w/2, y + h/2), Vector2.new(x + w/2, y + h/2 - corner_len)}
    }
    
    for i = 1, 8 do
        if corners[i] then
            pcall(function()
                corners[i].From = positions[i][1]
                corners[i].To = positions[i][2]
                corners[i].Visible = G
            end)
        end
    end
end

local function update_skeleton(p, esp, character)
    if not character or not esp or not esp.skeleton then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    local la = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftHand") or character:FindFirstChild("LeftUpperArm")
    local ra = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand") or character:FindFirstChild("RightUpperArm")
    local ll = character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftLowerLeg") or character:FindFirstChild("LeftFoot")
    local rl = character:FindFirstChild("Right Leg") or character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("RightFoot")
    
    if not hrp or not head or not torso then return end
    
    local hpos, hvis = world_to_viewport(head.Position)
    local tpos, tvis = world_to_viewport(torso.Position)
    
    if hvis and esp.skeleton.head then
        pcall(function()
            esp.skeleton.head.Position = Vector2.new(hpos.X, hpos.Y)
            esp.skeleton.head.Visible = G
        end)
    end
    
    if tvis and esp.skeleton.torso then
        pcall(function()
            local tsize = Vector2.new(30, 40)
            esp.skeleton.torso.Position = Vector2.new(tpos.X - tsize.X/2, tpos.Y - tsize.Y/2)
            esp.skeleton.torso.Size = tsize
            esp.skeleton.torso.Visible = G
        end)
    end
    
    if la and tvis then
        local lpos, lvis = world_to_viewport(la.Position)
        if lvis and esp.skeleton.leftarm then
            pcall(function()
                esp.skeleton.leftarm.From = Vector2.new(tpos.X, tpos.Y)
                esp.skeleton.leftarm.To = Vector2.new(lpos.X, lpos.Y)
                esp.skeleton.leftarm.Visible = G
            end)
        end
    end
    
    if ra and tvis then
        local rpos, rvis = world_to_viewport(ra.Position)
        if rvis and esp.skeleton.rightarm then
            pcall(function()
                esp.skeleton.rightarm.From = Vector2.new(tpos.X, tpos.Y)
                esp.skeleton.rightarm.To = Vector2.new(rpos.X, rpos.Y)
                esp.skeleton.rightarm.Visible = G
            end)
        end
    end
    
    if ll and tvis then
        local llpos, llvis = world_to_viewport(ll.Position)
        if llvis and esp.skeleton.leftleg then
            pcall(function()
                esp.skeleton.leftleg.From = Vector2.new(tpos.X, tpos.Y + 15)
                esp.skeleton.leftleg.To = Vector2.new(llpos.X, llpos.Y)
                esp.skeleton.leftleg.Visible = G
            end)
        end
    end
    
    if rl and tvis then
        local rlpos, rlvis = world_to_viewport(rl.Position)
        if rlvis and esp.skeleton.rightleg then
            pcall(function()
                esp.skeleton.rightleg.From = Vector2.new(tpos.X, tpos.Y + 15)
                esp.skeleton.rightleg.To = Vector2.new(rlpos.X, rlpos.Y)
                esp.skeleton.rightleg.Visible = G
            end)
        end
    end
end

local function hide_player(p)
    if E[p] then
        for _, d in pairs(E[p]) do
            if type(d) == "table" then
                for _, sd in pairs(d) do
                    pcall(function() sd.Visible = false end)
                end
            else
                pcall(function() d.Visible = false end)
            end
        end
    end
end

local function process_player(p)
    if not G or not p or p == L then return end
    
    local c = p.Character
    if not c then return end
    
    local r = c:FindFirstChild("HumanoidRootPart")
    local h = c:FindFirstChild("Humanoid")
    
    if not r or not h or h.Health <= 0 then return end
    
    local v2, d3, vf = world_to_viewport(r.Position)
    if not vf then return end
    
    local esp = construct_player_esp(p)
    if not esp then return end
    
    local dist_scale = math.clamp(600 / (d3 + 0.01), 0.6, 2.5)
    local box_width = math.floor(45 * dist_scale)
    local box_height = math.floor(90 * dist_scale)
    local x, y = v2.X, v2.Y
    
    local team_color = (p.Team and L.Team and p.Team == L.Team) and P.friend or P.enemy
    
    if esp.box and esp.box_outline then
        pcall(function()
            esp.box.Position = Vector2.new(x - box_width/2, y - box_height/2)
            esp.box.Size = Vector2.new(box_width, box_height)
            esp.box.Color = team_color
            esp.box.Visible = G
            
            esp.box_outline.Position = Vector2.new(x - box_width/2 - 1, y - box_height/2 - 1)
            esp.box_outline.Size = Vector2.new(box_width + 2, box_height + 2)
            esp.box_outline.Visible = G
        end)
    end
    
    update_corners(esp, x, y, box_width, box_height)
    
    if esp.health_bg and esp.health_fill then
        local hp = h.Health
        local max_hp = h.MaxHealth
        local percent = hp / max_hp
        local bar_height = box_height
        local bar_width = 5
        
        local health_color = percent > 0.6 and P.health_green or percent > 0.3 and P.health_yellow or P.health_red
        
        pcall(function()
            esp.health_bg.Position = Vector2.new(x + box_width/2 + 5, y - box_height/2)
            esp.health_bg.Size = Vector2.new(bar_width, bar_height)
            esp.health_bg.Visible = G
            
            esp.health_fill.Position = Vector2.new(x + box_width/2 + 5, y + box_height/2 - (bar_height * percent))
            esp.health_fill.Size = Vector2.new(bar_width, bar_height * percent)
            esp.health_fill.Color = health_color
            esp.health_fill.Visible = G
        end)
    end
    
    if esp.name then
        pcall(function()
            esp.name.Position = Vector2.new(x, y - box_height/2 - 22)
            esp.name.Text = string.upper(p.Name)
            esp.name.Visible = G
        end)
    end
    
    if esp.distance and L.Character and L.Character:FindFirstChild("HumanoidRootPart") then
        local lr = L.Character.HumanoidRootPart
        local dist = math.floor((lr.Position - r.Position).Magnitude)
        pcall(function()
            esp.distance.Position = Vector2.new(x, y + box_height/2 + 20)
            esp.distance.Text = tostring(dist) .. " M"
            esp.distance.Visible = G
        end)
    end
    
    if esp.head and c:FindFirstChild("Head") then
        local head = c.Head
        local hpos, hvis = world_to_viewport(head.Position)
        if hvis then
            pcall(function()
                esp.head.Position = Vector2.new(hpos.X, hpos.Y)
                esp.head.Visible = G
            end)
        end
    end
    
    if esp.tracer and C then
        pcall(function()
            esp.tracer.From = Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y)
            esp.tracer.To = Vector2.new(x, y - box_height/3)
            esp.tracer.Color = team_color
            esp.tracer.Visible = G
        end)
    end
    
    update_skeleton(p, esp, c)
end

local function cleanup()
    for p, _ in pairs(E) do
        if not p or not p.Parent then
            cleanup_player(p)
        end
    end
end

local function full_reset()
    for _, d in pairs(D) do
        pcall(function() d:Remove() end)
    end
    D = {}
    E = {}
    if F then pcall(function() F:Remove() end) F = nil end
end

local M = {}

function M.Enable()
    G = true
    if not F then
        F = safe_draw("Circle", {
            Radius = 120,
            Color = P.fov,
            Thickness = 1.25,
            NumSides = 72,
            Filled = false,
            Transparency = 0.85,
            Visible = true,
            Position = C and Vector2.new(C.ViewportSize.X/2, C.ViewportSize.Y/2) or Vector2.new(960, 540)
        })
    end
end

function M.Disable()
    G = false
    if F then pcall(function() F.Visible = false end) end
    for p, _ in pairs(E) do
        hide_player(p)
    end
end

function M.Toggle()
    if G then M.Disable() else M.Enable() end
end

function M.SetFOVRadius(r)
    if F then
        pcall(function() F.Radius = r end)
    end
end

function M.Reset()
    full_reset()
end

function M.IsEnabled()
    return G
end

S.RunService.RenderStepped:Connect(function()
    if not C then C = S.Workspace.CurrentCamera end
    if not C then return end
    
    update_fov()
    
    if G then
        for _, p in pairs(S.Players:GetPlayers()) do
            if p ~= L then
                process_player(p)
            end
        end
        cleanup()
    end
end)

_G.VISUALS = M

return M
